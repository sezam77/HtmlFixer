export class Generator {
    requestMap;
    constructor() {
        this.requestMap = new Map();
    }
    abortRequest(requestId) {
        const state = this.requestMap.get(requestId);
        if (!state)
            return;
        if (state.abortController) {
            try {
                state.abortController.abort();
            }
            catch (error) { }
        }
        if (state.options?.onFinish) {
            state.options.onFinish();
        }
        this.requestMap.delete(requestId);
    }
    /**
     * @returns return value is not important because request would be finished anyway. So use "options".
     */
    async generateRequest(requestParams, options) {
        const context = SillyTavern.getContext();
        const requestId = context.uuidv4();
        const isStream = requestParams?.custom?.stream ?? false;
        this.requestMap.set(requestId, {
            abortController: options?.abortController,
            isStream,
            options,
        });
        if (!isStream) {
            try {
                if (options?.onStart) {
                    options.onStart(requestId);
                }
                const response = await context.ConnectionManagerRequestService.sendRequest(requestParams.profileId, requestParams.prompt, requestParams.maxTokens, requestParams.custom);
                if (this.requestMap.get(requestId)) {
                    if (options?.onEntry) {
                        options.onEntry(response);
                    }
                    if (options?.onFinish) {
                        options.onFinish(response);
                    }
                }
            }
            catch (error) {
                if (options?.onFinish) {
                    options.onFinish(undefined, error);
                }
            }
            finally {
                this.requestMap.delete(requestId);
            }
        }
        else {
            try {
                const responseGen = await context.ConnectionManagerRequestService.sendRequest(requestParams.profileId, requestParams.prompt, requestParams.maxTokens, requestParams.custom);
                if (options?.onStart) {
                    options.onStart(requestId);
                }
                let lastChunk;
                for await (const chunk of responseGen()) {
                    lastChunk = chunk;
                    if (options?.onEntry) {
                        options.onEntry(chunk);
                    }
                }
                if (options?.onFinish) {
                    options.onFinish(lastChunk);
                }
            }
            catch (error) {
                if (options?.onFinish) {
                    options.onFinish(undefined, error);
                }
            }
            finally {
                this.requestMap.delete(requestId);
            }
        }
        return requestId;
    }
    getActiveRequest(requestId) {
        return this.requestMap.get(requestId)?.abortController;
    }
    getAllActiveRequests() {
        const activeRequests = new Map();
        for (const [id, state] of this.requestMap) {
            activeRequests.set(id, state.abortController);
        }
        return activeRequests;
    }
}
//# sourceMappingURL=generate.js.map