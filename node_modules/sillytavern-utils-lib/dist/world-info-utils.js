import { selected_world_info, st_createWorldInfoEntry, st_getCharaFilename, WI_METADATA_KEY, world_info, } from './config.js';
/**
 * @returns Entries by world name. <worldName, entries[]>
 */
export async function getActiveWorldInfo(include, targetCharacterIndex) {
    function includedType(type) {
        return include.includes('all') || include.includes(type);
    }
    const context = SillyTavern.getContext();
    let entries = {};
    const isGlobal = includedType('global');
    if (isGlobal && selected_world_info?.length) {
        for (const worldName of selected_world_info) {
            const worldInfo = await context.loadWorldInfo(worldName);
            if (!worldInfo) {
                continue;
            }
            if (!entries[worldName]) {
                entries[worldName] = [];
            }
            Object.values(worldInfo.entries).forEach((entry) => {
                entries[worldName].push(entry);
            });
        }
    }
    const isChat = includedType('chat');
    if (isChat) {
        const worldName = context.chatMetadata[WI_METADATA_KEY];
        if (worldName && !entries[worldName]) {
            entries[worldName] = [];
            const worldInfo = await context.loadWorldInfo(worldName);
            if (worldInfo) {
                Object.values(worldInfo.entries).forEach((entry) => {
                    entries[worldName].push(entry);
                });
            }
        }
    }
    const isCharacter = includedType('character');
    if (isCharacter && targetCharacterIndex) {
        const character = context.characters[targetCharacterIndex];
        let worldsToSearch = new Set();
        const baseWorldName = character?.data?.extensions?.world;
        if (baseWorldName) {
            worldsToSearch.add(baseWorldName);
        }
        const fileName = st_getCharaFilename(targetCharacterIndex);
        const extraCharLore = world_info.charLore?.find((e) => e.name === fileName);
        if (extraCharLore) {
            worldsToSearch = new Set([...worldsToSearch, ...extraCharLore.extraBooks]);
        }
        for (const worldName of worldsToSearch) {
            const worldInfo = await context.loadWorldInfo(worldName);
            if (!worldInfo || entries[worldName]) {
                continue;
            }
            entries[worldName] = [];
            Object.values(worldInfo.entries).forEach((entry) => {
                entries[worldName].push(entry);
            });
        }
    }
    const isPersona = includedType('persona');
    if (isPersona) {
        const worldName = context.powerUserSettings.persona_description_lorebook;
        if (worldName && !entries[worldName]) {
            entries[worldName] = [];
            const worldInfo = await context.loadWorldInfo(worldName);
            if (worldInfo) {
                Object.values(worldInfo.entries).forEach((entry) => {
                    entries[worldName].push(entry);
                });
            }
        }
    }
    return entries;
}
/**
 * @throws {Error} if entry/world not found
 */
export async function applyWorldInfoEntry({ entry, selectedWorldName, skipSave = false, skipReload = false, operation = 'auto', }) {
    const context = SillyTavern.getContext();
    const worldInfo = await context.loadWorldInfo(selectedWorldName);
    if (!worldInfo) {
        throw new Error('Failed to load world info');
    }
    const values = Object.values(worldInfo.entries);
    const lastEntry = values.length > 0 ? values[values.length - 1] : undefined;
    // Find existing entry with the same key if needed
    let targetEntry;
    if (operation === 'update' || operation === 'auto') {
        const existingEntry = Object.values(worldInfo.entries).find((e) => e.uid === entry.uid);
        if (existingEntry) {
            if (operation === 'auto') {
                // In auto mode, update existing entry
                targetEntry = existingEntry;
            }
            else if (operation === 'update') {
                targetEntry = existingEntry;
            }
        }
        else if (operation === 'update') {
            throw new Error('Entry not found for update operation');
        }
    }
    const operationResult = targetEntry ? 'update' : 'add';
    // Create new entry if needed
    if (!targetEntry) {
        targetEntry = st_createWorldInfoEntry(selectedWorldName, worldInfo);
        if (!targetEntry) {
            throw new Error('Failed to create entry');
        }
        if (lastEntry) {
            const newId = targetEntry.uid;
            Object.assign(targetEntry, lastEntry);
            targetEntry.uid = newId;
            targetEntry;
        }
    }
    // Update entry properties
    targetEntry.key = entry.key;
    targetEntry.content = entry.content;
    targetEntry.comment = entry.comment;
    // Save and update UI only if not skipping
    if (!skipSave) {
        await context.saveWorldInfo(selectedWorldName, worldInfo);
    }
    if (!skipReload) {
        context.reloadWorldInfoEditor(selectedWorldName, true);
    }
    return {
        entry: targetEntry,
        operation: operationResult,
    };
}
//# sourceMappingURL=world-info-utils.js.map