export interface VersionChange<F, T> {
    from: string;
    to: string;
    action: (previous: F) => Promise<T> | T;
}
export interface SettingsInitResult<T> {
    version: {
        changed: boolean;
        old?: string;
        new: string;
    };
    formatVersion: {
        changed: boolean;
        old?: string;
        new: string;
    };
    oldSettings: any | null;
    newSettings: T;
}
export declare class ExtensionSettingsManager<T> {
    readonly settingsKey: string;
    readonly defaultSettings: T;
    constructor(key: string, defaultSettings: T);
    /**
     * If defaultSettings has "version" and "formatVersion" properties, they will be used to track version and format version changes.
     *
     * For example, if you want to show a notification when a new version is released, you can check "result.version.changed".
     *
     * @param [options={}]
     * @param [options.strategy='recursive'] - 'recursive' will migrate old settings with the default settings.
     *
     * For complex settings, you can specify a custom migration strategy. For example, if you change the field name from "old" to "new", you can use:
     * @example
     * [
     *   {
     *     from: 'FORMAT-0.1.0',
     *     to: 'FORMAT-0.1.1',
     *     action: (previous) => {
     *       const data = {
     *         ...previous,
     *         new: previous.old,
     *       };
     *       delete data.old;
     *       return data;
     *     },
     *   },
     * ]
     */
    initializeSettings<S extends any, _V = S>(options?: {
        strategy?: 'recursive' | Array<VersionChange<any, any>>;
    }): Promise<SettingsInitResult<T>>;
    getSettings(): T;
    updateSetting<K extends keyof T>(key: K, value: T[K]): void;
    saveSettings(): void;
    resetSettings(): void;
}
//# sourceMappingURL=extension-settings-manager.d.ts.map